# Oona by Example

## Overview
Oona is a simple modeling and programming language. Oona uses an evaluation model that is similar to Prolog or Icon where expresions and statements either execute sucessfully or fail.

This document is a constructive approach to introducing Oona. It's similar to the book The Little Schemer.

Now, in the words of Mills Lanes, let's get it on...

### Data Declarations
Data declarations form one side of our abstraction triangle. Declaring variables and user data types is straightforward. User defined data have a syntax that, while different than the mainstream, should be familiar to Haskell and C users.

#####(1)	Let i  = 0Introduce a variable and initialize it to 0. The variable has an inferred type of Int since 0 is that default type.#####(2)	Let i : Int = 0This is the same as (1) but the type is explicitly specified.#####(3)	Let f = 0.0	Let f : Float = 0.0	Let s = ""a string""	Let s : String = ""a string""Compare the inferred type of a literal with its explict form.#####(4)	Let i = Int (0.0)Type names can be used to do explicit conversions. We can convert a literal floating point value into an Int. That becomes the type of the variable so we don't have to specify it explicitly.#####(5)	Let one = 1	Let one = Int (1)	Let one :Int = 1All of these statements are equivalent.#####(6)	Let a :Int[] = { 0 1 2 3 4 }Fixed length arrays are an intrinsic part of Oona. #####(7)	a[1]Output:	1Arrays are 0 based.#####(8)	Let f :Int[8] = 0A fixed length array can be declared having a specific size. We can also initialize all of its cells to some value.#####(9)	Data Point = { x: Int y:Int }Create new data types with the Data statement.#####(10)	Data Person = { name :String age :Int }The members of a Data type have a name and a type, both separated by a colon. Note that syntax is a lot like Let syntax.#####(11)	Data Point = { x :Int = 0 y: Int = 0 }Members of a data type are 0 initialized, but we can specify the default values explicitly.#####(12)	Data Point = { x :Int y: Int length :Int <- sqrt (x*x +  y*y)Data types can have computed members that automatically update much like a spreadsheet cell.#####(13)	Let p = Person { ""Clark Kent"" 27 }Use constructor syntax to create a value of a some Data type. Here, the init values must occur in the order in which the members are defined.#####(14)	Let p = Person { name = ""Clark Kent"" age = 27 }Constructor syntax also supports key value initialization.#####(15)	Let p : Person = { ""Clark Kent"" 27 }We can infer the format of an anonymous constructor if the type has been specified explicitly.#####(16)	Data Person = Student { name: String id: String major: String }	  | Teacher { name: String id: String subject: String }We enumerate the forms Data may have. The bar '|' allows us to list a closed set of allowed forms of some Data type.#####(17)	Data Person = { name: String id: String } & (Student { major: String } |	  | Teacher { subject: String } )We can move common parts into a shared section. The ampersand '&' operator concatenates specifications. So '|' and '&' together can be used to express a number of relationships.#####(18)	Data? Person = { name :String age :Int }	Data? Student = Person & { major: String }	Data? Teacher = Person & { subject: String }The preceding Data was closed. All of the allowed forms were specified upfront. In constract, an open Data type is like inheritance. We don't need to know all possible forms beforehand. In fact, the separte forms can be specified in separate compilation units.#####(19)	Let a = NullPointers are available. Use '^' to indicate that a variable is a pointer.#####(20)	Let a:^Int = 0This is equivalent to the above#####(21)	Let a = 1	Let b = ^aThe type of b is inferred based on its initial value.#####(22)	Let b :^Int = ^aThe type can be explicitly given#####(23)	b = aA pointer variable without the '^' means dereference. This places the value of a into the cell that b points to.#####(24)	^b = ^aThis sets b to point to the a#####(25)	Let b :^^Int = Null	^^b = ^aif b is a pointer to a pointer, then set address of pointer's pointer address to address of a.### Goal Driven Evaluation

When evaluating an expression, the act of evaluation my succeed or fail. Upon success, a value is returned from the evaluator. Upon failure, no value is returned because the computation could not complete.
#####(26)	1 + 2Output:	3+' was able to act on the supplied arguments.#####(27)	1 + ""car""Output:	FailNo implicit conversion allows '+' to combined an integer and a string.#####(28)	1 < 2Output:	2When a logical comparison succeeds, the right hand side is returned.#####(29)	1 > 2Output:	Fail1 is not greater than 2#####(30)	if 1 > 2 { output (""true"") }	else { output (""not true"") }Output:	not trueThe if statement is goal driven. On success, it's true part is executed. On failure, the optional else part is evaluated.#####(31)	output 1 > 2	output (""done"")Output:	doneFailure propagates to calling functions. The first output does not execute because it's arguments failed to evaluate.#####(32)	Let a = 1 > 2	if a { output (""true"") }	else { output (""not true"") }Output:	2	doneThis is equivalent to the preceding. The assignment to a fails. Through failure propagation, a takes on the value Fail which the 'if' statement recognizes.#####(33)	output 1 < 2	output (""done"")Output:	2	doneOk according to example (25) and (28)#####(34)	Let a = (1 > 2)?	Output (""a is "" a)Output:	a = FalseSometimes it's necessary to know if an expression has failed or not. The '?' operator returns true when an expression has suceeded, false otherwise.#####(35)	if a output (""a is true"")	else output (""a is false"")Output:	a is trueBecause 'if' is failure driven, checking a false value may not work as intended. Although the value of a from (31) is False, if still follows the success path, because False is not the same as Fail#####(36)	if a == True output (""a is true"")	else output (""a is false"")Output:	a is falseThis is the correct way to test for logical values.#### Generators

Generators are expressions that yield multiple values. The values are obtained when the expression is "re-entered", meaning the evaluator revaluates the expression without reinitializing it first. This feature is like generators in Icon or Python, or the IEnumerable comprehension in C#.

#####(37)	1..10This expression will generate the digits from 1 to 10 as it is re-entered. The range operator '..' is passive. It needs to be pumped by an outside agent.#####(38)	1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10This is equivalent to the preceeding. The bar '|' operator, when used in expressions, as a choice generator.#####(39)	1 > 2 | output ""1 is not greater than 2""Output:	1|' is different form '..' in that '|' will evaluate and return the first choice that succeeds. Re-entry will return the next available choice that succeeds.#####(40)	output (1..10)Output:	1Output does not consume generators. It takes the first value yielded and completes.#####(41)	every output (1..10 "", "")Output:	1, 2, 3, 4, 5, 6, 7, 8, 9, 10,The every operator exhaustively re-enters generative expressions until all values have been yielded or a failure occurs.#####(42)	every output (1..10 ""-"" 1..10 "","")Output:	1-1, 2-2, 3-3, 4-4, 5-5, 6-6, 7-7, 8-8, 9-9, 10-10,Every re-enters all generators simultaneously.#####(43)	1 < 2 & 2 < 3The 'and' operator succeeds when both of its operands succeed. It returns the value of the last expression as its answer. When re-entered, '&' will backtrack right to left to produce more values.#####(44)	every output (1..2 ""-"") & output (1..2 "", "")Output:	1-1,2, 2-1,2,When used with 'every' operator,  '&' exhausts the rightmost generator before backtacking.#####(45)	every let a = 1..2 & output (a ""-"" 1..2 "","")Output:	1-1, 1-2, 2-1, 2-2As in Prolog, after backtracking, '&' will reset its right argument and then enter it.#####(46)	every output (somefile.readline())Read and print every line in a file.### Control Statements
Oona provides a number of control statements. Most should be familiar to those familiar with languages like C or Pascal.

#####(47)	let a = 0	while (a < 10) { ++a }The while statement works much like its C counterpart. The difference is that while is goal driven, not value driven. While will continuously evaluate its predicate anew and upon successful evaluation, it will perform its block. A failure will cause while to terminate.#####(48)	for i = 1 & j = 10; i != j; ++i & --j { … }A for loop is a lot like its C counterpart. There are three sections, separated by ; and a block representing the actions to perform during the loop. Within a section, conjunction is used when there are multiple separate actions to be performed.#####(49)	until a > 10 { … }The until loop is similar to a while loop except it executes its body while the predicate fails.#####(50)	do { … } while a > 10	do { … } until a > 10Both the do and until have a postfix form where they test their predicate after an iteration rather than before.#####(51)	repeat { … }	repeat 10 { … }Finally, the repeat form is used to repeat an action forever (the first form) or a specific number of times (the second form).#####(52)	for let i = 1 & let j = 10; i <> j; ++i & --j { … }	while (let i = read()) { … }	repeat 10 as i { … }Some loop forms allow the introduction of variables that only last for the life of the loop. Variables cannot be introduced for until loops, as those loops run as long as the predicate fails. There is no value to be passed into the loop action in that case.#####(53)	if let i = read() { … }	elif i = 5 { … }	else { print i }The if statement may also introduce variables that are accessible to its actions.#####(54)	break	continueBreak and continue have the same purpose as their counterparts in C.#####(55)	every print (read()); 	{ … }This is why a ; is needed when every is adjacent to an unrelated block.### Operators
Mirroring C, Oona provides a number of operators that make expressions some what terser.

#####(56)	5 + 5	2 – 1	2 * 5	3 / 1	5 % 4	2 ** 16Output:	10	1	10	3	1	32768Basic arithmetic operators. Add, subtract, multiply, divide, modulus, and exponent. All of these operators fail when one of their operands have failed to evaluate.#####(57)	Let a = 1	++a	--a	a--	a++As in C, and with C semantics, we have preincrement, predecrement, postincrement and postdecrement operators.#####(58)	++^a	--^a	^a++	^a--They work on pointer addresses too. ^ binds tighter than the increment and decrement operators.#####(59)	a[1]The array operator extracts a slice from an array.#####(60)	a[2 3]It also supports multiple dimensions.#####(61)	every a[1..5]We can use 'every' to produce all values within a range.#####(62)	every some-arrayIt also works on the entire array.#####(63)	every a[0..3 0..3]This yields all the values in the diagonal.#####(64)	if (1 > 2)? == true { print “success” }	else { print “failed” }Output:	failedAs discussed previously, 'if' is failure driven and boolean values need to be compared with true or false directly.#####(65)	if is (1 > 2)? { print “success” }	else { print “failed” }Output:	failedAs a convenience, use the ‘is’ operator to drive our goal driven control structures. ‘Is’ converts boolean true to true, and boolean false to failure.#####(66)	1 == 1	1 < 2	2 > 1	5 >= ( 1 + 4)	6 <= 7	1 != 2	!aLogical  operators are present but they are goal driven. They fail when their premise is not true. They return their right operand when their premise is true. Use the ? operator to resolve them to a Boolean value. Note that the not operator ‘!’ fails when its premise succeeds and succeeds when its premise fails.#####(67)	a | b	a & bThe alternation and conjunction operators were introduced in the section 'Generators'.To reiterate, alternation returns the first expression that succeeds. If no expression succeeds, it fails. When resumed by a generative expression, ‘|’ will return the successive expression that succeeds or fail. The conjunction operator succeeds when all of its expressions succeed, failing otherwise. It will backtrack  to generate more answers when resumed by a generative expression.#####(68)	0x1100 and 0x0100	0x1100 or 0x0100	0x1100 xor 0x0100Output:	0x0100	0x1100	0x1000Bitwise logical operators perform as they do in C.  Since Pico uses ‘&’ and ‘|’ for other purposes, the word form of the bitwise operators are used instead.#####(69)	2 >> 1	4 << 1	-2 >> 1	-2 >>> 1Output:	1 	8	1	-1Unlike in C, the basic bitwise operators are logical shifts. For an arithmetic right shift, the >>> operator is used. (May change this to be implementation dependent as in C.)#####(70)	“\u00ab”	“\U000000ab”	“\n”	“\t”Inside string and character literals, ‘\’ provides a means to specify characters that can’t be typed directly at the keyboard.#####(71)	let a = 5 iff b>5 | bThe 'iff' operator is an operator the evaluates and returns its first operand when the second succeeds. In this example, a is assigned 5 if variable b is greater than 5, otherwise a is assigned the value of b.#####(72)	let a = 5 < b | 5This is equivalent to the preceding. The predicated expression, as introduced in (63), is useful when we can’t use the natural behavior of an operator to return the appropriate value. (Perhaps the desired value is nested in a more complex expression.)
### Function Declarations
Functions represent another side of our abstraction triangle. Since Oona is an imperative language, functions may have side effects, although pure functions are possible too.#####(73)	def add (a :Int b: Int) : Int {	    return a + b	}Functions are created with the def keyword. Note that commas are not necessary but can be used when there is ambiguity.#####(74)	add (1 2)Output:	3Invoking the function.#####(75)	add (a = 1 b = 2)Output:	3Functions can be called using keyword syntax as well.#####(76)	add (1 b = 2)Output:	ErrorPositional and keyword arguments cannot be mixed.#####(77)	def add (a: Int b: Int) : Int { return a + b }	def add (a: Float b: Float) : Float { return a + b }Functions can be overloaded. The overload resolution is static and happens at compile time.#####(78)	def operator+ (a: String b: String) : Int { … }Operators may be overloaded as well.#####(79)	some-func (a b c)	a .some-func (b c)Oona has syntactic sugar that uses dot notation to call a function. These two calls are equivalent.#####(80)	some-func (a b)	a .some-func (b)	a `some-func bFor binary functions, there is additonal sugar.  The ` turns a binary function into an infix function.#####(81)	def sum (a… :Int) : Int {	    Let r = 0	    r = r + every a	    return r	}Variadic arguments are supported. The variadic argument must be the last (or only) argument of the function. Variadic arguments must be typed.#####(82)	class Counter (Int) {	   def value () : Int { return this }	   def incr () : void { ++this }	}A class has no state. Rather it is parameterized over the Data type specified. The 'this' identifier implicitly references this parameter. This counter class works for all Int's.#####(83)	Let a = 0	a .incr()	output (a.value())Output:	1Now, as long as the Counter class definition is in scope, we can call counter methods on an Int.### Class Declarations
The third side of our abstraction triangle isn't quite like classes in languages like C++ or Java. Classes do represent operations and behavior, but no data is defined within. Rather, classes are like a bundle of functions closed over some data -- a fine grained module. Classes can make significant use of meta variables that will be described in the next section.

#####(84)	class CounterSet (Int) {	    def set-to (v :Int) : void { this = v }	}Multiple classes over some type can be in scope at the same time.#####(85)	a .set-to (10)	a `set-to 10As long as there are no method ambiguity, we can call methods from either in scope class. Note, methods also support the infix syntactic sugar. Methods taking 1 parameter is actually binary since the 'this' argument is implied.#####(86)	Counter(a).incr()If there were ambiguity, we can used the full canonical method call to insure the method from the correct class is used.#####(87)	Data IntExtra = { value: Int lim: Int }	class Counter (IntExtra) {	    def value () : Int { return this.value }	    def incr() : void { ++this.value }	}	class CounterSet (IntExtra) {	    def set-to (v :Int) : void { this.value = v }	}We can give other types Counter and CounterSet classes too.#####(88)	class CounterLimit (IntExtra) {	    def set-steps-to (s: Int) : void { this.lim = s }	}We can create another interface for IntExtra too.#####(89)	class Counter (IntExtra) {	    def value () : Int { return this.value }	    def incr() : void { if this.lim > 0 { ++this.value; --this.lim } }	}But we might want to refine our existing classes to support this notion of limit.#####(90)	class? ICounter {	    def value () : Int	    def incr () : void	}	class? ICounterSet {	    def set-to (Int) : void	}	class? ICounterLimit {	    def set-steps-to (Int) : void	}Nothing forces our two behavioral implementations to implement the same interface. We can do that by first describing the interfaces. An unparameterized class represents an interface. We can give a default implementation of a method and that will be evaluated within the context of a parameterized class that implements the interface. But here, we simply provide method prototypes.Note, we don't provide a parameter. But we could. For interfaces, the parameter must be a meta variable. See the section on Meta Variables.#####(91)	class Counter (Int) : ICounter { … }	class CounterSet (Int) : ICounterSet { … }	class Counter (IntExtra) : ICounter { … }	class CounterSet : ICounterSet { … }	class CounterLimit : ICounterLimit { … }Now when we implement these classes, we specify what interfaces are being implemented. The compiler will insure that, at a minmum, all methods without a default implementation is implemented. Note that a class may implement multiple interfaces. Separate each interface with a '&'. Also note that only interfaces can be listed in the implementation section. Not concrete classes.#####(92)	type Counterable = ICounter & ICounterSet	type LimitedCounterable = Counterable & ICounterLimitTypes can be used alias a class or to group behavior into a logical unit.#####(93)	type IntCounterable = Counter(Int) & CounterSet(Int)Types can be declared over concrete implementations or abstract implementations.#####(94)	type Counterable(Int) = Counter(Int) & CounterSet(Int)Types can be parameterized as well. This example is logically equivalent to the preceding example.#####(95)	def receive-string (s :String a:^Int) { … a.incr() … }		Let some-int = 0	receive-string (""some string"", some-int)This function does something with a string and then increments a counter. We pass in a pointer to an Int so that the external value can be modified. Otherwise, the function would get a local copy and modify that. This example illustrates that when a class is unspecified, all classes visible at the definition site, can be used.#####(96)	def receive-string (s :String a:^Counter(Int)) { … a.incr() … }		Let some-int = 0	receive-string (""some string"", some-int)This time, we limit the a to be Counterable(Int). Again, it’s a pointer since the class is concrete and will be copied otherwise. 'some-int' is implicitly coerced into a Counter(Int). CounterSet(Int) methods cannot be called. Counter(Int) must be available to our code at this point as well.Note that some-int is statically wrapped by a Counter(Int).#####(97)	def receive-string (s :String a:ICounter) { … a.incr() … }		Let some-int = 0	receive-string (""some string"", some-int)Here we use the generic counter interface which represents anything that implements it. We don't need a pointer to it, since that’s implied for an interface. Here some-int is dynamically resolved to Counter(Int).#####(98)	class Logger (Counter(Int)) { … }Classes and types can be the parameter to other classes and types.#####(99)	class Logger (ICounter) { … }This one is more general thatn the preceding since it works for anything that can implement ICounter.

### Meta Variables and Modifiers
Meta variables are like generic parameters as found in C++ tempates, C# and Java generic. Modifiers are user defined tags that annotate data and can be used as documention or as discriminators to aid pattern matching.
#####(100)	def add (a: T? b: T?) { return a + b }Meta variables follow the uniform substitution rule. 'a' and 'b' must both have the same type. That type must support the operations used by the body of the function.#####(101)	def add (a: T? b: U?) { return a + b }Here, a and b may be different types. But the operations used must be defined for them.#####(102)	Data Point (T?) = { x :T y :T }	Person (T? U?) = { name: String id: T :age U }Even Data can use meta variables.#####(103)	class Counter(T?) {	    def value () : T { … }	    def set-to (a: T) { … }	}Classes can use the metavariable which can affect its API.#####(104)	class? ICounter(T?) {	    def value () : T { … }	    def set-to (a: T) { … }	}Interfaces can have an API specific to the type specified by a meta variable.#####(105)	#####(106)	#####(107)	#####(108)	#####(109)	#####(110)	#####(111)	#####(112)	#####(113)	#####(114)	#####(115)	